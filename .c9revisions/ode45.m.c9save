{"ts":1353773227434,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function [tout,xout] = ode45(FUN,tspan,x0,pair,ode_fcn_format,tol,trace,count)\n\n% Copyright (C) 2001, 2000 Marc Compere\n% This file is intended for use with Octave.\n% ode45.m is free software; you can redistribute it and/or modify it\n% under the terms of the GNU General Public License as published by\n% the Free Software Foundation; either version 2, or (at your option)\n% any later version.\n%\n% ode45.m is distributed in the hope that it will be useful, but\n% WITHOUT ANY WARRANTY; without even the implied warranty of\n% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n% General Public License for more details at www.gnu.org/copyleft/gpl.html.\n%\n% --------------------------------------------------------------------\n%\n% ode45 (v1.11) integrates a system of ordinary differential equations using\n% 4th & 5th order embedded formulas from Dormand & Prince or Fehlberg.\n%\n% The Fehlberg 4(5) pair is established and works well, however, the\n% Dormand-Prince 4(5) pair minimizes the local truncation error in the\n% 5th-order estimate which is what is used to step forward (local extrapolation.)\n% Generally it produces more accurate results and costs roughly the same\n% computationally.  The Dormand-Prince pair is the default.\n%\n% This is a 4th-order accurate integrator therefore the local error normally\n% expected would be O(h^5).  However, because this particular implementation\n% uses the 5th-order estimate for xout (i.e. local extrapolation) moving\n% forward with the 5th-order estimate should yield errors on the order of O(h^6).\n%\n% The order of the RK method is the order of the local *truncation* error, d.\n% The local truncation error is defined as the principle error term in the\n% portion of the Taylor series expansion that gets dropped.  This portion of\n% the Taylor series exapansion is within the group of terms that gets multipled\n% by h in the solution definition of the general RK method.  Therefore, the\n% order-p solution created by the RK method will be roughly accurate to\n% within O(h^(p+1)).  The difference between two different-order solutions is\n% the definition of the \"local error,\" l.  This makes the local error, l, as\n% large as the error in the lower order method, which is the truncation\n% error, d, times h, resulting in O(h^(p+1)).\n% Summary:   For an RK method of order-p,\n%            - the local truncation error is O(h^p)\n%            - the local error (used for stepsize adjustment) is O(h^(p+1))\n%\n% This requires 6 function evaluations per integration step.\n%\n% Both the Dormand-Prince and Fehlberg 4(5) coefficients are from a tableu in\n% U.M. Ascher, L.R. Petzold, Computer Methods for  Ordinary Differential Equations\n% and Differential-Agebraic Equations, Society for Industrial and Applied Mathematics\n% (SIAM), Philadelphia, 1998\n%\n% The error estimate formula and slopes are from\n% Numerical Methods for Engineers, 2nd Ed., Chappra & Cannle, McGraw-Hill, 1985\n%\n% Usage:\n%         [tout, xout] = ode45(FUN, tspan, x0, pair, ode_fcn_format, tol, trace, count)\n%\n% INPUT:\n% FUN   - String containing name of user-supplied problem description.\n%         Call: xprime = fun(t,x) where FUN = 'fun'.\n%         t      - Time (scalar).\n%         x      - Solution column-vector.\n%         xprime - Returned derivative COLUMN-vector; xprime(i) = dx(i)/dt.\n% tspan - [ tstart, tfinal ]\n% x0    - Initial value COLUMN-vector.\n% pair  - flag specifying which integrator coefficients to use:\n%            0 --> use Dormand-Prince 4(5) pair (default)\n%            1 --> use Fehlberg pair 4(5) pair\n% ode_fcn_format - this specifies if the user-defined ode function is in\n%         the form:     xprime = fun(t,x)   (ode_fcn_format=0, default)\n%         or:           xprime = fun(x,t)   (ode_fcn_format=1)\n%         Matlab's solvers comply with ode_fcn_format=0 while\n%         Octave's lsode() and sdirk4() solvers comply with ode_fcn_format=1.\n% tol   - The desired accuracy. (optional, default: tol = 1.e-6).\n% trace - If nonzero, each step is printed. (optional, default: trace = 0).\n% count - if nonzero, variable 'rhs_counter' is initalized, made global\n%         and counts the number of state-dot function evaluations\n%         'rhs_counter' is incremented in here, not in the state-dot file\n%         simply make 'rhs_counter' global in the file that calls ode45\n%\n% OUTPUT:\n% tout  - Returned integration time points (column-vector).\n% xout  - Returned solution, one solution column-vector per tout-value.\n%\n% The result can be displayed by: plot(tout, xout).\n%\n% Marc Compere\n% CompereM@asme.org\n% created : 06 October 1999\n% modified: 17 January 2001\n\nif nargin < 8, count = 0; end\nif nargin < 7, trace = 0; end\nif nargin < 6, tol = 1.e-6; end\nif nargin < 5, ode_fcn_format = 0; end\nif nargin < 4, pair = 0; end\n\npow = 1/6; % see p.91 in the Ascher & Petzold reference for more infomation.\n\nif (pair==0),\n   % Use the Dormand-Prince 4(5) coefficients:\n    a_(1,1)=0;\n    a_(2,1)=1/5;\n    a_(3,1)=3/40; a_(3,2)=9/40;\n    a_(4,1)=44/45; a_(4,2)=-56/15; a_(4,3)=32/9;\n    a_(5,1)=19372/6561; a_(5,2)=-25360/2187; a_(5,3)=64448/6561; a_(5,4)=-212/729;\n    a_(6,1)=9017/3168; a_(6,2)=-355/33; a_(6,3)=46732/5247; a_(6,4)=49/176; a_(6,5)=-5103/18656;\n    a_(7,1)=35/384; a_(7,2)=0; a_(7,3)=500/1113; a_(7,4)=125/192; a_(7,5)=-2187/6784; a_(7,6)=11/84;\n    % 4th order b-coefficients\n    b4_(1,1)=5179/57600; b4_(2,1)=0; b4_(3,1)=7571/16695; b4_(4,1)=393/640; b4_(5,1)=-92097/339200; b4_(6,1)=187/2100; b4_(7,1)=1/40;\n    % 5th order b-coefficients\n    b5_(1,1)=35/384; b5_(2,1)=0; b5_(3,1)=500/1113; b5_(4,1)=125/192; b5_(5,1)=-2187/6784; b5_(6,1)=11/84; b5_(7,1)=0;\n    for i=1:7,\n     c_(i)=sum(a_(i,:));\n    end\nelse, % pair==1 so use the Fehlberg 4(5) coefficients:\n    a_(1,1)=0;\n    a_(2,1)=1/4;\n    a_(3,1)=3/32; a_(3,2)=9/32;\n    a_(4,1)=1932/2197; a_(4,2)=-7200/2197; a_(4,3)=7296/2197;\n    a_(5,1)=439/216; a_(5,2)=-8; a_(5,3)=3680/513; a_(5,4)=-845/4104;\n    a_(6,1)=-8/27; a_(6,2)=2; a_(6,3)=-3544/2565; a_(6,4)=1859/4104; a_(6,5)=-11/40;\n    % 4th order b-coefficients (guaranteed to be a column vector)\n    b4_(1,1)=25/216; b4_(2,1)=0; b4_(3,1)=1408/2565; b4_(4,1)=2197/4104; b4_(5,1)=-1/5;\n    % 5th order b-coefficients (also guaranteed to be a column vector)\n    b5_(1,1)=16/135; b5_(2,1)=0; b5_(3,1)=6656/12825; b5_(4,1)=28561/56430; b5_(5,1)=-9/50; b5_(6,1)=2/55;\n    for i=1:6,\n     c_(i)=sum(a_(i,:));\n    end\nend % if (pair==0)\n\n\n% Initialization\nt0 = tspan(1);\ntfinal = tspan(2);\nt = t0;\nhmax = (tfinal - t)/2.5;\nhmin = (tfinal - t)/1e9;\nh = (tfinal - t)/100; % initial guess at a step size\nx = x0(:);            % this always creates a column vector, x\ntout = t;             % first output time\nxout = x.';           % first output solution\n\nif count==1,\n global rhs_counter\n if ~exist('rhs_counter'),rhs_counter=0; end\nend % if count\n\nif trace\n clc, t, h, x\nend\n\nif (pair==0),\n\n   k_ = x*zeros(1,7);  % k_ needs to be initialized as an Nx7 matrix where N=number of rows in x\n                       % (just for speed so octave doesn't need to allocate more memory at each stage value)\n\n   % Compute the first stage prior to the main loop.  This is part of the Dormand-Prince pair caveat.\n   % Normally, during the main loop the last stage for x(k) is the first stage for computing x(k+1).\n   % So, the very first integration step requires 7 function evaluations, then each subsequent step\n   % 6 function evaluations because the first stage is simply assigned from the last step's last stage.\n   % note: you can see this by the last element in c_ is 1.0, thus t+c_(7)*h = t+h, ergo, the next step.\n   if (ode_fcn_format==0), % (default)\n      k_(:,1)=feval(FUN,t,x); % first stage\n   else, % ode_fcn_format==1\n      k_(:,1)=feval(FUN,x,t);\n   end % if (ode_fcn_format==1)\n\n   % increment rhs_counter\n   if (count==1), rhs_counter = rhs_counter + 1; end\n\n   % The main loop using Dormand-Prince 4(5) pair\n   while (t < tfinal) & (h >= hmin),\n      if t + h > tfinal, h = tfinal - t; end\n\n      % Compute the slopes by computing the k(:,j+1)'th column based on the previous k(:,1:j) columns\n      % notes: k_ needs to end up as an Nxs, a_ is 7x6, which is s by (s-1),\n      %        s is the number of intermediate RK stages on [t (t+h)] (Dormand-Prince has s=7 stages)\n      if (ode_fcn_format==0), % (default)\n         for j = 1:6,\n            k_(:,j+1) = feval(FUN, t+c_(j+1)*h, x+h*k_(:,1:j)*a_(j+1,1:j)');\n         end\n      else, % ode_fcn_format==1\n         for j = 1:6,\n            k_(:,j+1) = feval(FUN, x+h*k_(:,1:j)*a_(j+1,1:j)', t+c_(j+1)*h);\n         end\n      end % if (ode_fcn_format==1)\n\n      % increment rhs_counter\n      if (count==1), rhs_counter = rhs_counter + 6; end\n\n      % compute the 4th order estimate\n      x4=x + h* (k_*b4_); % k_ is Nxs (or Nx7) and b4_ is a 7x1\n\n      % compute the 5th order estimate\n      x5=x + h*(k_*b5_); % k_ is Nxs (or Nx7) and b5_ is a 7x1\n\n      % estimate the local truncation error\n      gamma1 = x5 - x4;\n\n      % Estimate the error and the acceptable error\n      delta = norm(gamma1,'inf');       % actual error\n      tau = tol*max(norm(x,'inf'),1.0); % allowable error\n\n      % Update the solution only if the error is acceptable\n      if (delta<=tau),\n         t = t + h;\n         x = x5;    % <-- using the higher order estimate is called 'local extrapolation'\n         tout = [tout; t];\n         xout = [xout; x.'];\n      end % if (delta<=tau)\n\n      if trace\n         home, t, h, x\n      end % if trace\n\n      % Update the step size\n      if (delta==0.0),\n       delta = 1e-16;\n      end % if (delta==0.0)\n      h = min(hmax, 0.8*h*(tau/delta)^pow);\n\n      % Assign the last stage for x(k) as the first stage for computing x(k+1).\n      % This is part of the Dormand-Prince pair caveat.\n      % k_(:,7) has already been computed, so use it instead of recomputing it\n      % again as k_(:,1) during the next step.\n      k_(:,1)=k_(:,7);\n\n   end % while (t < tfinal) & (h >= hmin)\n\nelse, % pair==1 --> use RK-Fehlberg 4(5) pair\n\n   k_ = x*zeros(1,6);  % k_ needs to be initialized as an Nx6 matrix where N=number of rows in x\n                       % (just for speed so octave doesn't need to allocate more memory at each stage value)\n \n   % The main loop using Dormand-Prince 4(5) pair\n   while (t < tfinal) & (h >= hmin),\n      if t + h > tfinal, h = tfinal - t; end\n\n      % Compute the slopes by computing the k(:,j+1)'th column based on the previous k(:,1:j) columns\n      % notes: k_ needs to end up as an Nx6, a_ is 6x5, which is s by (s-1),  (RK-Fehlberg has s=6 stages)\n      %        s is the number of intermediate RK stages on [t (t+h)]\n      if (ode_fcn_format==0), % (default)\n     k_(:,1)=feval(FUN,t,x); % first stage\n      else, % ode_fcn_format==1\n\t k_(:,1)=feval(FUN,x,t);\n      end % if (ode_fcn_format==1)\n\n      if (ode_fcn_format==0), % (default)\n         for j = 1:5,\n            k_(:,j+1) = feval(FUN, t+c_(j+1)*h, x+h*k_(:,1:j)*a_(j+1,1:j)');\n         end\n      else, % ode_fcn_format==1\n         for j = 1:5,\n            k_(:,j+1) = feval(FUN, x+h*k_(:,1:j)*a_(j+1,1:j)', t+c_(j+1)*h);\n         end\n      end % if (ode_fcn_format==1)\n\n      % increment rhs_counter\n      if (count==1), rhs_counter = rhs_counter + 6; end\n\n      % compute the 4th order estimate\n      x4=x + h* (k_(:,1:5)*b4_); % k_(:,1:5) is an Nx5 and b4_ is a 5x1\n\n      % compute the 5th order estimate\n      x5=x + h*(k_*b5_); % k_ is the same as k_(:,1:6) and is an Nx6 and b5_ is a 6x1\n\n      % estimate the local truncation error\n      gamma1 = x5 - x4;\n\n      % Estimate the error and the acceptable error\n      delta = norm(gamma1,'inf');       % actual error\n      tau = tol*max(norm(x,'inf'),1.0); % allowable error\n\n      % Update the solution only if the error is acceptable\n      if (delta<=tau),\n         t = t + h;\n         x = x5;    % <-- using the higher order estimate is called 'local extrapolation'\n         tout = [tout; t];\n         xout = [xout; x.'];\n      end % if (delta<=tau)\n\n      if trace\n         home, t, h, x\n      end % if trace\n\n      % Update the step size\n      if (delta==0.0),\n       delta = 1e-16;\n      end % if (delta==0.0)\n      h = min(hmax, 0.8*h*(tau/delta)^pow);\n\n   end % while (t < tfinal) & (h >= hmin)\n\n\nend % if (pair==0),\n\nif (t < tfinal)\n   disp('Step size grew too small.')\n   t, h, x\nend\n"]],"start1":0,"start2":0,"length1":0,"length2":12290}]],"length":12290}
