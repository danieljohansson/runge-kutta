{"ts":1353773241127,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\nhttp://reference.wolfram.com/mathematica/tutorial/NDSolveExplicitRungeKutta.html\nhttp://users.powernet.co.uk/kienzle/octave/matcompat/scripts/ode_v1.11/ode45.m\n*/\n\n// ----- Euler -----\n\nvar euler = function (f, tSpan, y0, h) {\n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0;\n    \n    while (t[n] < tSpan[1]) {\n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        y[n+1] = y[n] + h * f(t[n], y[n]);\n        t[n+1] = t[n] + h;\n        n++;\n    }\n    \n    return {t:t, y:y, evals:n};\n};\n\n// ----- Heun (2nd order Runge-Kutta) -----\n\nvar heun = function (f, tSpan, y0, h) {\n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0;\n    var k1, k2;\n    \n    while (t[n] < tSpan[1]) {\n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        k1 = f(t[n], y[n]);\n        k2 = f(t[n] + h, y[n] + h*k1);\n        y[n+1] = y[n] + h/2 * (k1 + k2);\n        t[n+1] = t[n] + h;\n        n++;\n    }\n    \n    return {t:t, y:y, evals:n*2};\n};\n\n// ----- Heun-Euler (adaptive) -----\n\nvar heunEuler = function (f, tSpan, y0, h0, tol) {\n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0, evals = 0;\n    var k1, k2;\n    var h = h0 || 1e-3;\n    var r, scale;\n    \n    tol = tol || 1e-1;\n    \n    while (t[n] < tSpan[1]) {\n        \n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        k1 = f(t[n], y[n]);\n        k2 = f(t[n] + h, y[n] + h * k1);\n        \n        // r = error / h\n        r = Math.abs(1/2*k1 - 1/2*k2);\n        scale = 1/2 * tol / r;\n        \n        if (r < tol) {\n            y[n+1] = y[n] + h * k1;\n            t[n+1] = t[n] + h;\n            n++;\n        }\n        \n        if (scale < 0.1) h *= 0.1;\n        else if (scale > 4) h *= 4;\n        else h *= scale;\n        \n        if (h > 2) h = 2;\n        else if (h < 1e-6) h = 1e-6;\n        \n        evals += 2;\n    }\n    \n    return {t:t, y:y, evals:evals};\n};\n\n// ----- Midpoint (2nd order Runge-Kutta) -----\n\nvar midpoint = function (f, tSpan, y0, h) {\n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0;\n    \n    while (t[n] < tSpan[1]) {\n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        y[n+1] = y[n] + h * f(t[n] + h/2, y[n] + h/2*f(t[n], y[n]));\n        t[n+1] = t[n] + h;\n        n++;\n    }\n    \n    return {t:t, y:y, evals:n*2};\n};\n\n// ----- Runge-Kutta (4th order) ----- \n\nvar rk4 = function (f, tSpan, y0, h) {\n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0;\n    var k1, k2, k3, k4;\n    \n    while (t[n] < tSpan[1]) {\n        \n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        k1 = f(t[n], y[n]);\n        k2 = f(t[n] + h/2, y[n] + h/2*k1);\n        k3 = f(t[n] + h/2, y[n] + h/2*k2);\n        k4 = f(t[n] + h, y[n] + h*k3);\n        \n        y[n+1] = y[n] + h/6 * (k1 + 2*k2 + 2*k3 + k4);\n        \n        t[n+1] = t[n] + h;\n        n++;\n    }\n    \n    return {t:t, y:y, evals:n*4};\n};\n\n// ----- Dorman-Prince 5(4) (adaptive Runge-Kutta)\n\nvar dp54 = function (f, tSpan, y0, tol, h0) {\n    \n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0, i = 0;\n    var k1, k2, k3, k4, k5, k6, k7;\n    var h = h0 || (tSpan[1] - tSpan[0]) / 100; // initial guess\n    var r, scale;\n    \n    var a21 = 1/5,\n        a31 = 3/40, a32 = 9/40,\n        a41 = 44/45, a42 = -56/15, a43 = 32/9,\n        a51 = 19372/6561, a52 = -25360/2187, a53 = 64448/6561, a54 = -212/729,\n        a61 = 9017/3168, a62 = -355/33, a63 = 46732/5247, a64 = 49/176, a65 = -5103/18656,\n        a71 = 35/384, a73 = 500/1113, a74 = 125/192, a75 = -2187/6784, a76 = 11/84;\n    \n    // 5th order coefficients\n    var b1 = 35/384, b3 = 500/1113, b4 = 125/192, b5 = -2187/6784, b6 = 11/84; // b7 = 0;\n    \n    var c2 = 1/5, c3 = 3/10, c4 = 4/5, c5 = 8/9; // c6 = 1, c7 = 1;\n    \n    // coefficients for error calculation (e_i = b_i - b^_i)\n    var e1 = 71/57600, e3 = -71/16695, e4 = 71/1920,\n        e5 = -17253/339200, e6 = 22/525, e7 = -1/40;\n    \n    tol || (tol = 1e-3);\n    \n    // Initial calculation of slope in start point\n    // Utilize FSAL (first same as last) property of Dormand-Prince \n    k7 = f(t[0], y[0]);\n    \n    while (t[n] < tSpan[1]) {\n        \n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        k1 = k7;\n        k2 = f(t[n] + c2*h, y[n] + h*(a21*k1));\n        k3 = f(t[n] + c3*h, y[n] + h*(a31*k1 + a32*k2));\n        k4 = f(t[n] + c4*h, y[n] + h*(a41*k1 + a42*k2 + a43*k3));\n        k5 = f(t[n] + c5*h, y[n] + h*(a51*k1 + a52*k2 + a53*k3 + a54*k4));\n        k6 = f(t[n] + h, y[n] + h*(a61*k1 + a62*k2 + a63*k3 + a64*k4 + a65*k5));\n        k7 = f(t[n] + h, y[n] + h*(a71*k1 + a73*k3 + a74*k4 + a75*k5 + a76*k6));\n        \n        // r = estimated error / h\n        r = Math.abs(e1*k1 + e3*k3 + e4*k4 + e5*k5 + e6*k6 + e7*k7);\n        scale = 0.84 * Math.pow(tol / r, 1/4); // (1/2)^(1/4) ≈ 0.84\n        \n        // Step forward if accurate enough\n        if (r < tol) {\n            // Use 5th order estimation (local extrapolation)\n            y[n+1] = y[n] + h * (b1*k1 + b3*k3 + b4*k4 + b5*k5 + b6*k6);\n            t[n+1] = t[n] + h;\n            n++;\n        }\n        else {\n            // reset k7 if step is discarded (FSAL)\n            k7 = k1;\n        }\n        \n        // Adjust step size\n        if (scale < 0.1) h *= 0.1;\n        else if (scale > 4) h *= 4;\n        else h *= scale;\n        \n        if (h > 2) h = 2; // too large?\n        else if (h < 1e-9) h = 1e-9;\n        \n        i++;\n        \n        if (i > 1e5) {\n            throw 'Maximum numer of iterations (100 000) reached.';\n        }\n    }\n    \n    return {t:t, y:y, evals:1 + 6*i};\n};\n\n// ----- Dorman-Prince 4(5) (adaptive Runge-Kutta)\n\nvar dp45 = function (f, tSpan, y0, tol, h0) {\n    \n    var y = [y0];\n    var t = [tSpan[0]];\n    var n = 0, evals = 0;\n    var k1, k2, k3, k4, k5, k6, k7;\n    var h = h0 || (tSpan[1] - tSpan[0]) / 100; // initial guess\n    var r, scale;\n    \n    var a21 = 1/5,\n        a31 = 3/40, a32 = 9/40,\n        a41 = 44/45, a42 = -56/15, a43 = 32/9,\n        a51 = 19372/6561, a52 = -25360/2187, a53 = 64448/6561, a54 = -212/729,\n        a61 = 9017/3168, a62 = -355/33, a63 = 46732/5247, a64 = 49/176, a65 = -5103/18656,\n        a71 = 35/384, a73 = 500/1113, a74 = 125/192, a75 = -2187/6784, a76 = 11/84;\n    \n    // 4th order coefficients\n    var b1 = 5179/57600, b3 = 7571/16695, b4 = 393/640, b5 = -92097/339200, b6 = 187/2100, b7 = 1/40;\n    \n    var c2 = 1/5, c3 = 3/10, c4 = 4/5, c5 = 8/9; // c6 = 1, c7 = 1;\n    \n    // coefficients for error calculation (e_i = b_i - b^_i)\n    var e1 = 71/57600, e3 = -71/16695, e4 = 71/1920,\n        e5 = -17253/339200, e6 = 22/525, e7 = -1/40;\n    \n    tol = tol || 1e-3;\n    \n    while (t[n] < tSpan[1]) {\n        \n        // Don't go beyond tSpan[1]\n        if (t[n] + h > tSpan[1]) h = tSpan[1] - t[n];\n        \n        k1 = f(t[n], y[n]);\n        k2 = f(t[n] + c2*h, y[n] + h*(a21*k1));\n        k3 = f(t[n] + c3*h, y[n] + h*(a31*k1 + a32*k2));\n        k4 = f(t[n] + c4*h, y[n] + h*(a41*k1 + a42*k2 + a43*k3));\n        k5 = f(t[n] + c5*h, y[n] + h*(a51*k1 + a52*k2 + a53*k3 + a54*k4));\n        k6 = f(t[n] + h, y[n] + h*(a61*k1 + a62*k2 + a63*k3 + a64*k4 + a65*k5));\n        k7 = f(t[n] + h, y[n] + h*(a71*k1 + a73*k3 + a74*k4 + a75*k5 + a76*k6));\n        \n        // r = estimated error / h\n        r = Math.abs(e1*k1 + e3*k3 + e4*k4 + e5*k5 + e6*k6 + e7*k7);\n        scale = 0.84 * Math.pow(tol / r, 1/4); // (1/2)^(1/4) ≈ 0.84\n        \n        // Step forward if accurate enough\n        if (r < tol) {\n            // Use 4th order estimate\n            y[n+1] = y[n] + h * (b1*k1 + b3*k3 + b4*k4 + b5*k5 + b6*k6 + b7*k7);\n            t[n+1] = t[n] + h;\n            n++;\n        }\n        \n        // Adjust step size\n        if (scale < 0.1) h *= 0.1;\n        else if (scale > 4) h *= 4;\n        else h *= scale;\n        \n        if (h > 2) h = 2; // too large?\n        else if (h < 1e-9) h = 1e-9;\n        \n        evals += 7;\n    }\n    \n    return {t:t, y:y, evals:evals};\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":8121}]],"length":8121}
